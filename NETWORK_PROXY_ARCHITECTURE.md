# Network Proxy/Adapter Architecture

## Обзор

Эта документация описывает архитектуру сетевого прокси/адаптера для игровой модели SeaBattle. Архитектура обеспечивает изоляцию бизнес-логики от реализации транспорта, позволяя игровой модели работать как с локальным, так и с сетевым источником данных без дублирования кода.

## Основные компоненты

### 1. IGameModelSource (Интерфейс)

**Файл:** `IGameModelSource.h`

Абстрактный интерфейс, определяющий контракт для источников игровой модели. Скрывает детали реализации (локальная игра или сетевое взаимодействие).

**Основные методы:**
- `startGame()` - начать новую игру
- `processShot(row, col)` - обработать выстрел
- `getPlayerCellState(player, row, col)` - получить состояние клетки игрока
- `getEnemyCellState(player, row, col)` - получить состояние клетки противника
- `getCurrentPlayer()` - получить текущего игрока
- `getGameState()` - получить состояние игры
- `setEventCallback(callback)` - установить обработчик событий
- `isValidShot(row, col)` - проверить валидность выстрела

**Типы событий (GameEventType):**
- `ShotRequest` - запрос выстрела
- `ShotResponse` - ответ на выстрел (попадание/промах)
- `ShipDestroyed` - корабль уничтожен
- `GameOver` - игра завершена
- `PlayerSwitch` - смена игрока
- `Error` - ошибка

### 2. LocalGameModelSource

**Файл:** `LocalGameModelSource.h`

Локальная реализация интерфейса `IGameModelSource`. Инкапсулирует работу с классом `GameModel` для локальной игры на одном компьютере.

**Особенности:**
- Создает и управляет экземпляром `GameModel`
- Генерирует события (`GameEvent`) при изменении состояния игры
- Полностью самодостаточная реализация без внешних зависимостей

### 3. NetworkGameModelSource

**Файл:** `NetworkGameModelSource.h`

Сетевая реализация интерфейса `IGameModelSource`. Предоставляет заглушку для будущей сетевой функциональности.

**Архитектура для будущей реализации:**
- Подключение к серверу/клиенту
- Отправка запросов на выстрел по сети
- Получение ответов от противника
- Синхронизация состояния игры
- Локальный кэш для быстрого доступа к данным
- Очередь сетевых событий
- Обработка ошибок сети

**Примечание:** В текущей реализации выбрасывает исключение `std::runtime_error`, указывая, что сетевая функциональность еще не реализована.

### 4. GameModelAdapter

**Файлы:** `ModelAdapter.h`, `ModelAdapter.cpp`

Адаптер, который:
- Использует `IGameModelSource` для абстракции источника данных
- Преобразует события (`GameEvent`) в callback'и для UI
- Обеспечивает прозрачность источника для верхних уровней (MainWindow, GameScreen)

**Новые возможности:**
- Конструктор принимает `std::unique_ptr<IGameModelSource>` (по умолчанию использует `LocalGameModelSource`)
- Метод `setModelSource()` позволяет переключать источник в runtime
- Метод `handleGameEvent()` преобразует события в callback'и

## Архитектурные принципы

### 1. Инверсия зависимостей (Dependency Inversion)

```
┌─────────────────┐
│  MainWindow     │
│  (UI Layer)     │
└────────┬────────┘
         │ зависит от
         ▼
┌─────────────────┐
│ GameModelAdapter│
│  (Adapter)      │
└────────┬────────┘
         │ зависит от
         ▼
┌─────────────────────────────┐
│   IGameModelSource          │
│   (Interface)               │
└─────────┬───────────────────┘
          │ реализуют
    ┌─────┴─────┐
    ▼           ▼
┌────────┐  ┌──────────┐
│ Local  │  │ Network  │
│ Source │  │ Source   │
└────────┘  └──────────┘
```

### 2. Прозрачность источника

UI код (MainWindow, GameScreen) не знает и не должен знать, с каким источником он работает. Весь код остается неизменным при переключении между локальным и сетевым режимом.

### 3. Событийная модель

События (`GameEvent`) обеспечивают асинхронную коммуникацию между источником и адаптером:
- Локальный источник генерирует события синхронно
- Сетевой источник может генерировать события асинхронно (из другого потока)

### 4. Отсутствие дублирования кода

Бизнес-логика игры находится в `GameModel`. Оба источника используют одну и ту же логику:
- `LocalGameModelSource` напрямую использует `GameModel`
- `NetworkGameModelSource` полагается на сервер, который также использует `GameModel`

## Примеры использования

### Создание адаптера с локальным источником (текущая реализация)

```cpp
// По умолчанию используется локальный источник
auto adapter = std::make_unique<GameModelAdapter>();
```

### Создание адаптера с сетевым источником (будущая реализация)

```cpp
auto networkSource = std::make_unique<SeaBattle::NetworkGameModelSource>();
auto adapter = std::make_unique<GameModelAdapter>(std::move(networkSource));
```

### Переключение источника в runtime

```cpp
GameModelAdapter adapter;

// Начинаем с локального режима
adapter.startGame();
// ... играем локально ...

// Переключаемся на сетевой режим
auto networkSource = std::make_unique<SeaBattle::NetworkGameModelSource>();
adapter.setModelSource(std::move(networkSource));
adapter.startGame();
// ... играем по сети ...
```

### Настройка callback'ов (одинаково для обоих режимов)

```cpp
adapter.setCellUpdateCallback([](int player, int row, int col, SeaBattle::CellState state) {
    // Обработка обновления клетки
});

adapter.setPlayerSwitchCallback([](int newPlayer) {
    // Обработка смены игрока
});

adapter.setGameOverCallback([](int winner) {
    // Обработка завершения игры
});
```

## Будущие расширения

### 1. Реализация NetworkGameModelSource

Для полной реализации сетевого источника потребуется:

1. **Выбор сетевой библиотеки:**
   - Qt Network (рекомендуется, т.к. проект использует Qt)
   - Boost.Asio
   - Платформенные сокеты

2. **Протокол коммуникации:**
   - TCP для надежной доставки
   - JSON или Protocol Buffers для сериализации
   - Определение формата сообщений

3. **Клиент-серверная архитектура:**
   - Сервер управляет игровой сессией
   - Клиенты отправляют действия (выстрелы)
   - Сервер валидирует и транслирует результаты

4. **Синхронизация состояния:**
   - Начальная синхронизация (расстановка кораблей)
   - Инкрементальные обновления (выстрелы)
   - Обработка переподключений

### 2. Дополнительные типы источников

Архитектура позволяет легко добавить новые типы источников:
- `AIGameModelSource` - игра против ИИ
- `ReplayGameModelSource` - воспроизведение записанной игры
- `RemoteAIGameModelSource` - ИИ на удаленном сервере

### 3. Расширение событий

Можно добавить дополнительные типы событий:
- `ChatMessage` - текстовое сообщение от противника
- `ConnectionLost` - потеря соединения
- `SyncRequired` - требуется синхронизация
- `TimeoutWarning` - предупреждение о таймауте хода

## Преимущества архитектуры

1. **Изоляция:** Бизнес-логика изолирована от транспорта
2. **Расширяемость:** Легко добавить новые источники
3. **Тестируемость:** Можно создать mock-источники для тестирования
4. **Переиспользование:** Один UI-код работает со всеми источниками
5. **Гибкость:** Переключение режимов в runtime
6. **Поддерживаемость:** Изменения в одном источнике не влияют на другие

## Соответствие требованиям

✅ Разработан прокси-слой (адаптер) между игровыми моделями и сетевыми классами

✅ Абстрагирован источник ходов через интерфейс `IGameModelSource`

✅ Обеспечена прозрачная работа с игровыми событиями (выстрел, ответ, завершение, ошибка)

✅ Бизнес-логика изолирована от реализации транспорта

✅ Модель работает с локальным и сетевым источником без дублирования кода
